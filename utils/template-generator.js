const fs = require('fs-extra');
const path = require('path');
const { logger } = require('./logger');

class IntelligentTemplateGenerator {
  constructor() {
    this.domainTemplates = {
      jira: {
        background: 'Given Jira is running and I have administrator privileges',
        commonSteps: ['the Jira instance is configured', 'the user has appropriate permissions', 'the feature flag is accessible']
      },
      web: {
        background: 'Given the web application is running and I am logged in',
        commonSteps: ['the page loads successfully', 'the user interface is responsive', 'all elements are visible']
      },
      api: {
        background: 'Given the API service is running and I have valid credentials',
        commonSteps: ['the endpoint is accessible', 'the request is valid', 'the response is received']
      },
      general: {
        background: 'Given the application is running and the user has access',
        commonSteps: ['the system is initialized', 'the user is authenticated', 'the functionality is available']
      }
    };
  }

  generateSummaryFromAnalysis(analysis, requirements) {
    logger.info('ðŸ“ Generating intelligent summary from analysis...');
    
    const template = `# ${analysis.mainFeature} - Requirements Summary

## ðŸ“‹ Overview
${analysis.description}

**Domain**: ${analysis.domain.charAt(0).toUpperCase() + analysis.domain.slice(1)}  
**Complexity**: ${analysis.complexity.charAt(0).toUpperCase() + analysis.complexity.slice(1)}  
**Source**: ${requirements.source || 'Direct Input'}  

## ðŸŽ¯ Features Identified
${analysis.features.map(f => `- ${f.charAt(0).toUpperCase() + f.slice(1)}`).join('\n')}

## ðŸ‘¥ User Stories
${analysis.userStories.map(story => 
`### ${story.title}
**As a** ${story.actor}  
**I want** ${story.goal}  
**So that** ${story.benefit}

**Acceptance Criteria:**
${story.criteria.map(c => `- ${c}`).join('\n')}
`).join('\n')}

## ðŸ§ª Test Scenarios
${analysis.scenarios.map(scenario => 
`### ${scenario.name}
**Type**: ${scenario.type.charAt(0).toUpperCase() + scenario.type.slice(1)} Test  
**Given** ${scenario.given}  
**When** ${scenario.when}  
**Then** ${scenario.then}
`).join('\n')}

${analysis.businessRules.length > 0 ? `## ðŸ“œ Business Rules
${analysis.businessRules.map((rule, index) => `${index + 1}. ${rule}`).join('\n')}` : ''}

## ðŸ”‘ Key Terms
${analysis.keywords.slice(0, 8).map(keyword => `\`${keyword}\``).join(', ')}

## ðŸ“Š Analysis Summary
- **Main Feature**: ${analysis.mainFeature}
- **User Stories**: ${analysis.userStories.length}
- **Test Scenarios**: ${analysis.scenarios.length}
- **Business Rules**: ${analysis.businessRules.length}
- **Complexity Level**: ${analysis.complexity}

---
*Generated by Auto-Coder Framework v2.0 - Intelligent Analysis Engine*
`;

    return template;
  }

  generateFeatureFromSummary(summaryContent) {
    logger.info('ðŸŽ¯ Generating BDD feature from summary...');
    
    const summary = this.parseSummaryContent(summaryContent);
    const domain = summary.domain.toLowerCase();
    const domainConfig = this.domainTemplates[domain] || this.domainTemplates.general;

    // Generate separate features for each user story
    let featureContent = '';
    
    summary.userStories.forEach((story, index) => {
      const featureName = `${story.actor} ${story.goal}`.replace(/^(.)/, (match) => match.toUpperCase());
      
      featureContent += `Feature: ${featureName}
  As ${story.actor}
  I want ${story.goal}
  So that ${story.benefit}
  
  Background:
    ${domainConfig.background}

`;

      // Add scenarios related to this user story
      const relatedScenarios = summary.scenarios.filter(scenario => {
        const scenarioLower = scenario.name.toLowerCase();
        const goalLower = story.goal.toLowerCase();
        const actorLower = story.actor.toLowerCase();
        
        // Check if scenario name contains key words from the goal or actor
        const goalWords = goalLower.split(' ').slice(0, 3); // Take first 3 words
        const hasGoalMatch = goalWords.some(word => word.length > 3 && scenarioLower.includes(word));
        const hasActorMatch = scenarioLower.includes(actorLower);
        
        return hasGoalMatch || hasActorMatch;
      });

      if (relatedScenarios.length > 0) {
        relatedScenarios.forEach(scenario => {
          const scenarioType = scenario.type === 'negative' ? '@negative' : '@positive';
          featureContent += `  ${scenarioType}
  Scenario: ${scenario.name}
    Given ${scenario.given}
    When ${scenario.when}
    Then ${scenario.then}${scenario.type === 'positive' ? '\n    And the operation should be logged for audit purposes' : '\n    And the system should remain stable'}

`;
        });
      } else {
        // Generate default scenarios for this user story
        featureContent += `  @positive
  Scenario: ${story.actor} successfully ${story.goal}
    Given ${this.generateGivenFromStory(story)}
    When ${this.generateWhenFromStory(story)}
    Then ${this.generateThenFromStory(story)}
    And the operation should be logged for audit purposes

`;
      }

      // Add separator between features
      if (index < summary.userStories.length - 1) {
        featureContent += '\n# ===== Next Feature =====\n\n';
      }
    });

    // Add system health check at the end
    featureContent += `
  @smoke
  Scenario: System Health Check
    Given the application is running
    When I check the system status
    Then all required services should be operational
    And no critical errors should be present

# Feature generated from requirements analysis
# Domain: ${summary.domain}
# User Stories: ${summary.userStories.length}
# Test Scenarios: ${summary.scenarios.length}
`;

    return featureContent;
  }

  generateGivenFromStory(story) {
    if (story.goal.includes('invite') && story.goal.includes('friend')) {
      return 'the user is logged in and has access to the invitation feature';
    } else if (story.goal.includes('organize') && story.goal.includes('work')) {
      return 'the user is logged in and has work items to organize';
    } else if (story.goal.includes('understand') && story.goal.includes('progress')) {
      return 'the manager is logged in and has team members with progress data';
    }
    return 'the application is running and the user is authenticated';
  }

  generateWhenFromStory(story) {
    if (story.goal.includes('invite') && story.goal.includes('friend')) {
      return 'the user sends invitations to friends';
    } else if (story.goal.includes('organize') && story.goal.includes('work')) {
      return 'the user organizes their work items';
    } else if (story.goal.includes('understand') && story.goal.includes('progress')) {
      return 'the manager views team progress information';
    }
    return `the user performs ${story.goal}`;
  }

  generateThenFromStory(story) {
    if (story.benefit && story.benefit !== story.goal) {
      return `${story.benefit}`;
    } else if (story.goal.includes('invite') && story.goal.includes('friend')) {
      return 'friends receive invitations and can join the service';
    } else if (story.goal.includes('organize') && story.goal.includes('work')) {
      return 'the user feels in control of their organized work';
    } else if (story.goal.includes('understand') && story.goal.includes('progress')) {
      return 'the manager can report on team success and failures';
    }
    return `the user successfully completes ${story.goal}`;
  }

  generateStepsFromFeature(featureContent, baseFileName = null) {
    logger.info('ðŸªœ Generating step definitions from feature...');
    
    const feature = this.parseFeatureContent(featureContent);
    const steps = this.extractStepsFromFeature(featureContent);
    const domain = this.extractDomainFromFeature(featureContent);
    
    // FIXED: Use consistent baseFileName for naming
    const nameToUse = baseFileName || feature.name;
    const names = this.generateCleanBaseNames(nameToUse);
    const pageObjectName = names.className;
    const variableName = names.variableName;
    const fileName = names.fileName;

    const stepDefinitions = `const { Given, When, Then, Before, After, setDefaultTimeout } = require('@cucumber/cucumber');
const { expect } = require('@playwright/test');
const ${pageObjectName} = require('../pages/${fileName}');

// Step definitions for ${names.displayName}
// Generated from feature file analysis
// Domain: ${domain}

setDefaultTimeout(30000);

let page;
let ${variableName};

Before(async function () {
  // Initialize browser and page for each scenario
  const { chromium } = require('@playwright/test');
  const browser = await chromium.launch({ headless: false });
  const context = await browser.newContext();
  page = await context.newPage();
  ${variableName} = new ${pageObjectName}(page);
  
  // Set up test data and environment
  this.testData = {
    timestamp: new Date().toISOString(),
    testId: Math.random().toString(36).substring(7)
  };
});

// Background steps
${this.generateBackgroundSteps(feature, domain, variableName)}

// Generated step definitions
${steps.given.map(step => this.generateGivenStep(step, variableName, domain)).join('\n\n')}

${steps.when.map(step => this.generateWhenStep(step, variableName, domain)).join('\n\n')}

${steps.then.map(step => this.generateThenStep(step, variableName, domain)).join('\n\n')}

// Common steps
Given('the application is running', async function () {
  await ${variableName}.navigate();
  await ${variableName}.waitForLoad();
});

When('I check the system status', async function () {
  await ${variableName}.checkSystemHealth();
});

Then('all required services should be operational', async function () {
  const isHealthy = await ${variableName}.verifySystemHealth();
  expect(isHealthy).toBe(true);
});

Then('no critical errors should be present', async function () {
  const errors = await ${variableName}.getCriticalErrors();
  expect(errors).toHaveLength(0);
});

Then('the operation should be logged for audit purposes', async function () {
  const logs = await ${variableName}.getAuditLogs();
  expect(logs).toContain(this.testData.testId);
});

Then('the system should remain stable', async function () {
  const isStable = await ${variableName}.verifySystemStability();
  expect(isStable).toBe(true);
});

After(async function () {
  // Cleanup after each scenario
  if (page) {
    await page.screenshot({ 
      path: \`reports/screenshots/\${this.testData.testId}-\${Date.now()}.png\`,
      fullPage: true 
    });
    await page.close();
  }
});

module.exports = {};
`;

    return stepDefinitions;
  }

  generatePageFromSteps(stepsContent, baseFileName = null) {
    logger.info('ðŸ“„ Generating page object from steps...');
    
    const analysis = this.analyzeStepsContent(stepsContent);
    const domain = analysis.domain;
    
    // FIXED: Use consistent baseFileName for naming
    const nameToUse = baseFileName || analysis.baseName || 'default';
    const names = this.generateCleanBaseNames(nameToUse);
    const className = names.className;

    const pageObject = `const { expect } = require('@playwright/test');

class ${className} {
  constructor(page) {
    this.page = page;
    this.baseUrl = process.env.BASE_URL || this.getDefaultUrl('${domain}');
    this.timeout = 30000;
    
    // Page selectors - dynamically generated based on domain
    this.selectors = ${this.generateSelectorsForDomain(domain)};
    
    // Domain-specific configuration
    this.config = ${this.generateDomainConfig(domain)};
  }

  getDefaultUrl(domain) {
    const urls = {
      jira: 'http://localhost:2990/jira',
      web: 'http://localhost:3000',
      api: 'http://localhost:8080/api',
      general: 'http://localhost:3000'
    };
    return urls[domain] || urls.general;
  }

  async navigate() {
    await this.page.goto(this.baseUrl);
    await this.waitForLoad();
  }

  async waitForLoad() {
    await this.page.waitForLoadState('networkidle');
    await this.page.waitForSelector(this.selectors.mainContent, { timeout: this.timeout });
  }

${this.generateDomainSpecificMethods(analysis, domain)}

  // System health and monitoring methods
  async checkSystemHealth() {
    const healthEndpoint = \`\${this.baseUrl}\${this.config.healthPath}\`;
    const response = await this.page.evaluate(async (url) => {
      try {
        const res = await fetch(url);
        return { status: res.status, ok: res.ok };
      } catch (error) {
        return { status: 0, ok: false, error: error.message };
      }
    }, healthEndpoint);
    
    return response;
  }

  async verifySystemHealth() {
    const health = await this.checkSystemHealth();
    return health.ok && health.status === 200;
  }

  async getCriticalErrors() {
    // Check browser console for critical errors
    const logs = await this.page.evaluate(() => {
      return window.console.errors || [];
    });
    
    return logs.filter(log => 
      log.level === 'error' && 
      (log.message.includes('critical') || log.message.includes('fatal'))
    );
  }

  async verifySystemStability() {
    // Check if page is still responsive
    try {
      await this.page.waitForSelector(this.selectors.mainContent, { timeout: 5000 });
      await this.page.evaluate(() => document.readyState);
      return true;
    } catch (error) {
      return false;
    }
  }

  async getAuditLogs() {
    // Retrieve audit logs (implementation depends on system)
    return await this.page.evaluate(() => {
      return window.auditLogs || [];
    });
  }

  // Helper methods
  async waitForElement(selector, timeout = this.timeout) {
    await this.page.waitForSelector(selector, { timeout });
  }

  async clickElement(selector) {
    await this.waitForElement(selector);
    await this.page.click(selector);
  }

  async fillInput(selector, value) {
    await this.waitForElement(selector);
    await this.page.fill(selector, value);
  }

  async getText(selector) {
    await this.waitForElement(selector);
    return await this.page.textContent(selector);
  }

  async verifyText(selector, expectedText) {
    const actualText = await this.getText(selector);
    expect(actualText).toContain(expectedText);
  }

  async takeScreenshot(name) {
    await this.page.screenshot({ 
      path: \`reports/screenshots/\${name}-\${Date.now()}.png\`,
      fullPage: true 
    });
  }
}

module.exports = ${className};

// Generated for domain: ${domain}
// Based on step definitions analysis
// Selectors and methods are dynamically generated
`;

    return pageObject;
  }

  generateTestsFromPages(pageContent, baseFileName = null) {
    logger.info('ðŸ§ª Generating Playwright tests from page objects...');
    
    const analysis = this.analyzePageContent(pageContent);
    
    // FIXED: Use consistent baseFileName for naming
    const nameToUse = baseFileName || analysis.baseName || 'default';
    const names = this.generateCleanBaseNames(nameToUse);
    const pageClassName = names.className;
    const variableName = names.variableName;
    const fileName = names.fileName;
    const testName = names.displayName;

    const testScript = `const { test, expect } = require('@playwright/test');
const ${pageClassName} = require('../pages/${fileName}');

// Playwright tests for ${testName}
// Generated from page object analysis
// Domain: ${analysis.domain}

test.describe('${testName} Tests', () => {
  let page;
  let ${variableName};

  test.beforeEach(async ({ browser }) => {
    const context = await browser.newContext({
      viewport: { width: 1920, height: 1080 },
      ignoreHTTPSErrors: true
    });
    page = await context.newPage();
    ${variableName} = new ${pageClassName}(page);
    
    // Set up test environment
    await ${variableName}.navigate();
  });

${this.generateTestCases(analysis, variableName)}

  test.afterEach(async () => {
    // Cleanup and capture artifacts
    await ${variableName}.takeScreenshot('test-cleanup');
    await page.close();
  });
});

// Performance tests
test.describe('${testName} Performance Tests', () => {
  test('page load performance', async ({ page }) => {
    const ${variableName} = new ${pageClassName}(page);
    
    const startTime = Date.now();
    await ${variableName}.navigate();
    const loadTime = Date.now() - startTime;
    
    expect(loadTime).toBeLessThan(5000); // 5 second threshold
  });
});

// Accessibility tests
test.describe('${testName} Accessibility Tests', () => {
  test('basic accessibility check', async ({ page }) => {
    const ${variableName} = new ${pageClassName}(page);
    await ${variableName}.navigate();
    
    // Check for basic accessibility requirements
    const hasTitle = await page.title();
    expect(hasTitle).toBeTruthy();
    
    const hasMainLandmark = await page.locator('main, [role="main"]').count();
    expect(hasMainLandmark).toBeGreaterThan(0);
  });
});
`;

    return testScript;
  }

  // Helper methods for parsing and generation
  parseSummaryContent(content) {
    const lines = content.split('\n');
    const summary = {
      mainFeature: '',
      description: '',
      domain: 'general',
      userStories: [],
      scenarios: []
    };

    let currentSection = '';
    let currentStory = null;
    let currentScenario = null;

    lines.forEach(line => {
      const trimmed = line.trim();
      
      if (trimmed.startsWith('# ') && !summary.mainFeature) {
        summary.mainFeature = trimmed.substring(2).replace(' - Requirements Summary', '');
      } else if (trimmed.startsWith('**Domain**:')) {
        summary.domain = trimmed.split(':')[1].trim().toLowerCase();
      } else if (trimmed.includes('## ðŸ“‹ Overview')) {
        currentSection = 'overview';
      } else if (trimmed.includes('## ðŸ‘¥ User Stories')) {
        currentSection = 'userStories';
      } else if (trimmed.includes('## ðŸ§ª Test Scenarios')) {
        currentSection = 'scenarios';
      } else if (currentSection === 'overview' && trimmed && !trimmed.startsWith('**')) {
        summary.description = trimmed;
      } else if (currentSection === 'userStories' && trimmed.startsWith('### User Story')) {
        if (currentStory) summary.userStories.push(currentStory);
        currentStory = { title: trimmed.substring(4), actor: '', goal: '', benefit: '', criteria: [] };
      } else if (currentStory && trimmed.startsWith('**As a**')) {
        currentStory.actor = trimmed.split('**As a**')[1].trim();
      } else if (currentStory && trimmed.startsWith('**I want**')) {
        currentStory.goal = trimmed.split('**I want**')[1].trim();
      } else if (currentStory && trimmed.startsWith('**So that**')) {
        currentStory.benefit = trimmed.split('**So that**')[1].trim();
      } else if (currentSection === 'scenarios' && trimmed.startsWith('### ')) {
        if (currentScenario) summary.scenarios.push(currentScenario);
        currentScenario = { name: trimmed.substring(4), given: '', when: '', then: '', type: 'positive' };
      } else if (currentScenario && trimmed.startsWith('**Given**')) {
        currentScenario.given = trimmed.split('**Given**')[1].trim();
      } else if (currentScenario && trimmed.startsWith('**When**')) {
        currentScenario.when = trimmed.split('**When**')[1].trim();
      } else if (currentScenario && trimmed.startsWith('**Then**')) {
        currentScenario.then = trimmed.split('**Then**')[1].trim();
      } else if (currentScenario && (trimmed.includes('Negative') || trimmed.includes('Error'))) {
        currentScenario.type = 'negative';
      }
    });

    if (currentStory) summary.userStories.push(currentStory);
    if (currentScenario) summary.scenarios.push(currentScenario);
    
    return summary;
  }

  parseFeatureContent(content) {
    const lines = content.split('\n');
    const feature = {
      name: '',
      baseName: '',
      description: '',
      scenarios: []
    };

    lines.forEach(line => {
      const trimmed = line.trim();
      if (trimmed.startsWith('Feature:')) {
        feature.name = trimmed.substring(8).trim();
        feature.baseName = feature.name.toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]/g, '');
      } else if (trimmed && !trimmed.startsWith('#') && !feature.description && feature.name) {
        feature.description = trimmed;
      }
    });

    return feature;
  }

  extractStepsFromFeature(content) {
    const steps = { given: [], when: [], then: [] };
    const lines = content.split('\n');

    lines.forEach(line => {
      const trimmed = line.trim();
      if (trimmed.startsWith('Given ')) {
        steps.given.push(trimmed.substring(6));
      } else if (trimmed.startsWith('When ')) {
        steps.when.push(trimmed.substring(5));
      } else if (trimmed.startsWith('Then ')) {
        steps.then.push(trimmed.substring(5));
      }
    });

    // Remove duplicates
    steps.given = [...new Set(steps.given)];
    steps.when = [...new Set(steps.when)];
    steps.then = [...new Set(steps.then)];

    return steps;
  }

  extractDomainFromFeature(content) {
    if (content.includes('# Domain: ')) {
      return content.split('# Domain: ')[1].split('\n')[0].trim();
    }
    return 'general';
  }

  generateBackgroundSteps(feature, domain, variableName) {
    const domainConfig = this.domainTemplates[domain] || this.domainTemplates.general;
    return `Given('${domainConfig.background.replace('Given ', '')}', async function () {
  // Background setup for ${domain} domain
  await ${variableName}.navigate();
  await ${variableName}.waitForLoad();
  
  // Domain-specific initialization
  ${domainConfig.commonSteps.map(step => `await ${variableName}.verify('${step}');`).join('\n  ')}
});`;
  }

  generateGivenStep(step, variableName, domain) {
    const cleanStep = step.replace(/['"]/g, '');
    return `Given('${step}', async function () {
  // Setup: ${cleanStep}
  await ${variableName}.setup('${cleanStep}');
  this.context = { step: '${cleanStep}', domain: '${domain}' };
});`;
  }

  generateWhenStep(step, variableName, domain) {
    const cleanStep = step.replace(/['"]/g, '');
    return `When('${step}', async function () {
  // Action: ${cleanStep}
  await ${variableName}.perform('${cleanStep}');
  this.result = await ${variableName}.getLastActionResult();
});`;
  }

  generateThenStep(step, variableName, domain) {
    const cleanStep = step.replace(/['"]/g, '');
    return `Then('${step}', async function () {
  // Verification: ${cleanStep}
  const result = await ${variableName}.verify('${cleanStep}');
  expect(result).toBe(true);
});`;
  }

  generateSelectorsForDomain(domain) {
    const selectors = {
      jira: {
        mainContent: '#jira',
        createButton: '#create_link',
        issueDialog: '.jira-dialog',
        watcherField: '#watchers',
        submitButton: '#create-issue-submit'
      },
      web: {
        mainContent: 'main, #main, .main-content',
        navigation: 'nav, .navigation',
        form: 'form',
        submitButton: '[type="submit"], .submit',
        errorMessage: '.error, .alert-error'
      },
      api: {
        mainContent: 'body',
        responseArea: '#response',
        requestForm: '#request-form',
        submitButton: '#send-request',
        statusCode: '.status-code'
      },
      general: {
        mainContent: 'main, body',
        navigation: 'nav',
        content: '.content',
        button: 'button',
        input: 'input'
      }
    };

    return JSON.stringify(selectors[domain] || selectors.general, null, 6);
  }

  generateDomainConfig(domain) {
    const configs = {
      jira: {
        healthPath: '/status',
        apiPath: '/rest/api/2',
        timeout: 30000
      },
      web: {
        healthPath: '/health',
        apiPath: '/api',
        timeout: 15000
      },
      api: {
        healthPath: '/health',
        apiPath: '',
        timeout: 10000
      },
      general: {
        healthPath: '/health',
        apiPath: '/api',
        timeout: 15000
      }
    };

    return JSON.stringify(configs[domain] || configs.general, null, 6);
  }

  generateDomainSpecificMethods(analysis, domain) {
    const methods = {
      jira: `
  // Jira-specific methods
  async enableFeatureFlag(flagName) {
    await this.page.goto(\`\${this.baseUrl}/secure/admin/ViewApplicationProperties.jspa\`);
    await this.fillInput('#flagName', flagName);
    await this.clickElement('#enable-flag');
  }

  async configureWatcherField() {
    await this.page.goto(\`\${this.baseUrl}/secure/admin/ViewIssueFields.jspa\`);
    await this.clickElement('[data-field="watcher"]');
    await this.clickElement('#configure-field');
  }

  async createIssue(issueData) {
    await this.clickElement(this.selectors.createButton);
    await this.waitForElement(this.selectors.issueDialog);
    
    if (issueData.watchers) {
      await this.fillInput(this.selectors.watcherField, issueData.watchers);
    }
    
    await this.clickElement(this.selectors.submitButton);
  }`,
      
      web: `
  // Web application methods
  async fillForm(formData) {
    for (const [field, value] of Object.entries(formData)) {
      await this.fillInput(\`[name="\${field}"], #\${field}\`, value);
    }
  }

  async submitForm() {
    await this.clickElement(this.selectors.submitButton);
    await this.waitForLoad();
  }

  async verifyErrorMessage(expectedMessage) {
    const errorElement = await this.page.locator(this.selectors.errorMessage);
    await expect(errorElement).toContainText(expectedMessage);
  }`,

      api: `
  // API testing methods
  async sendRequest(method, endpoint, data = null) {
    const response = await this.page.evaluate(async ({ method, endpoint, data, baseUrl }) => {
      const options = {
        method,
        headers: { 'Content-Type': 'application/json' }
      };
      
      if (data) {
        options.body = JSON.stringify(data);
      }
      
      const res = await fetch(\`\${baseUrl}\${endpoint}\`, options);
      return {
        status: res.status,
        data: await res.json()
      };
    }, { method, endpoint, data, baseUrl: this.baseUrl });
    
    return response;
  }

  async verifyResponse(response, expectedStatus) {
    expect(response.status).toBe(expectedStatus);
    return response;
  }`,

      general: `
  // General application methods
  async setup(stepDescription) {
    // Generic setup based on step description
    console.log(\`Setting up: \${stepDescription}\`);
  }

  async perform(stepDescription) {
    // Generic action based on step description
    console.log(\`Performing: \${stepDescription}\`);
  }

  async verify(stepDescription) {
    // Generic verification based on step description
    console.log(\`Verifying: \${stepDescription}\`);
    return true;
  }

  async getLastActionResult() {
    return { success: true, timestamp: new Date().toISOString() };
  }`
    };

    return methods[domain] || methods.general;
  }

  analyzeStepsContent(content) {
    const analysis = {
      className: '',
      domain: 'general',
      baseName: ''
    };

    // Extract class name from require statement
    const requireMatch = content.match(/require\(['"]\.\.\/pages\/(.+?)-page['"]\)/);
    if (requireMatch) {
      analysis.baseName = requireMatch[1];
      analysis.className = this.sanitizeClassName(analysis.baseName) + 'Page';
    }

    // Extract domain from comments
    const domainMatch = content.match(/\/\/ Domain: (\w+)/);
    if (domainMatch) {
      analysis.domain = domainMatch[1];
    }

    return analysis;
  }

  analyzePageContent(content) {
    const analysis = {
      className: '',
      domain: 'general',
      baseName: ''
    };

    // Extract class name
    const classMatch = content.match(/class (\w+) {/);
    if (classMatch) {
      analysis.className = classMatch[1];
      analysis.baseName = analysis.className.replace('Page', '').toLowerCase();
    }

    // Extract domain from comments
    const domainMatch = content.match(/\/\/ Generated for domain: (\w+)/);
    if (domainMatch) {
      analysis.domain = domainMatch[1];
    }

    return analysis;
  }

  generateTestCases(analysis, variableName) {
    const testBaseName = analysis.baseName || 'feature';
    return `
  test('${testBaseName} - main functionality', async () => {
    // Test main feature functionality
    await ${variableName}.setup('main functionality test');
    await ${variableName}.perform('main action');
    const result = await ${variableName}.verify('expected outcome');
    expect(result).toBe(true);
  });

  test('${testBaseName} - error handling', async () => {
    // Test error scenarios
    await ${variableName}.setup('error handling test');
    await ${variableName}.perform('invalid action');
    const isStable = await ${variableName}.verifySystemStability();
    expect(isStable).toBe(true);
  });

  test('${testBaseName} - system health', async () => {
    // Test system health
    const health = await ${variableName}.checkSystemHealth();
    expect(health.ok).toBe(true);
    
    const errors = await ${variableName}.getCriticalErrors();
    expect(errors).toHaveLength(0);
  });`;
  }

  // Name sanitization methods
  sanitizeClassName(name) {
    // Convert to PascalCase and remove invalid characters
    return name
      .replace(/[^a-zA-Z0-9\s]/g, ' ') // Replace special chars with spaces
      .split(/\s+/) // Split on whitespace
      .filter(word => word.length > 0) // Remove empty strings
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()) // PascalCase
      .join('') // Join without spaces
      .replace(/Page$/, '') + 'Page'; // Ensure single "Page" suffix
  }

  sanitizeVariableName(name) {
    // Convert to camelCase and remove invalid characters
    const words = name
      .replace(/[^a-zA-Z0-9\s]/g, ' ') // Replace special chars with spaces
      .split(/\s+/) // Split on whitespace
      .filter(word => word.length > 0); // Remove empty strings
    
    if (words.length === 0) return 'defaultPage';
    
    // First word lowercase, rest PascalCase
    const camelCase = words[0].toLowerCase() + 
      words.slice(1).map(word => 
        word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
      ).join('');
    
    return camelCase.replace(/Page$/, '') + 'Page'; // Ensure single "Page" suffix
  }

  sanitizeFileName(name) {
    // Convert to kebab-case for file names
    return name
      .replace(/[^a-zA-Z0-9\s]/g, ' ') // Replace special chars with spaces
      .split(/\s+/) // Split on whitespace
      .filter(word => word.length > 0) // Remove empty strings
      .map(word => word.toLowerCase()) // All lowercase
      .join('-') // Join with hyphens
      .replace(/-page$/, '') + '-page'; // Ensure single "-page" suffix
  }

  generateCleanBaseNames(baseFileName) {
    // Generate all naming variations from base file name
    const cleanBase = baseFileName.replace(/[^a-zA-Z0-9\s]/g, ' ').trim();
    
    return {
      className: this.sanitizeClassName(cleanBase),
      variableName: this.sanitizeVariableName(cleanBase),
      fileName: this.sanitizeFileName(cleanBase),
      displayName: cleanBase.split(/\s+/).map(word => 
        word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
      ).join(' ')
    };
  }

  // Utility methods
  toCamelCase(str) {
    return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase())
              .replace(/^[a-z]/, (g) => g.toUpperCase());
  }

  formatTestName(name) {
    return name.split(/(?=[A-Z])/).join(' ');
  }
}

module.exports = IntelligentTemplateGenerator;

module.exports = IntelligentTemplateGenerator;
